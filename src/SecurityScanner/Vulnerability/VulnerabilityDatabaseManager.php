<?php
namespace YC\CodeAnalysis\SecurityScanner\Vulnerability;

use YC\CodeAnalysis\Core\Database\DatabaseManager;
use YC\CodeAnalysis\SecurityScanner\Contracts\VulnerabilitySourceInterface;
use Psr\Log\LoggerInterface;

/**
 * 漏洞数据库管理器
 * 
 * 集成多个漏洞数据源，提供统一的漏洞查询接口
 */
class VulnerabilityDatabaseManager
{
    private DatabaseManager $database;
    private LoggerInterface $logger;
    private array $dataSources = [];
    private VulnerabilityCache $cache;
    private VulnerabilityNormalizer $normalizer;

    // 漏洞严重程度映射
    private array $severityMapping = [
        'critical' => 10.0,
        'high' => 8.5,
        'medium' => 6.0,
        'low' => 3.5,
        'info' => 1.0
    ];

    public function __construct(
        DatabaseManager $database,
        LoggerInterface $logger,
        VulnerabilityCache $cache,
        VulnerabilityNormalizer $normalizer
    ) {
        $this->database = $database;
        $this->logger = $logger;
        $this->cache = $cache;
        $this->normalizer = $normalizer;
        
        $this->initializeDataSources();
    }

    /**
     * 初始化数据源
     */
    private function initializeDataSources(): void
    {
        $this->dataSources = [
            'cve' => new CVEDatabaseConnector($this->database, $this->logger),
            'nvd' => new NVDConnector($this->logger),
            'snyk' => new SnykAPIConnector($this->logger),
            'security_advisories' => new SecurityAdvisoriesConnector($this->logger),
            'packagist' => new PackagistSecurityConnector($this->logger)
        ];
    }

    /**
     * 更新所有漏洞数据库
     */
    public function updateAllDatabases(): array
    {
        $results = [];
        
        foreach ($this->dataSources as $name => $source) {
            try {
                $this->logger->info("开始更新{$name}漏洞数据库");
                $result = $this->updateDataSource($name, $source);
                $results[$name] = $result;
                $this->logger->info("{$name}数据库更新完成", $result);
            } catch (\Exception $e) {
                $error = "更新{$name}数据库失败: " . $e->getMessage();
                $this->logger->error($error, ['exception' => $e]);
                $results[$name] = ['success' => false, 'error' => $error];
            }
        }

        // 清空缓存以确保使用最新数据
        $this->cache->clear();
        
        return $results;
    }

    /**
     * 更新单个数据源
     */
    private function updateDataSource(string $name, VulnerabilitySourceInterface $source): array
    {
        $startTime = microtime(true);
        
        // 获取最后更新时间
        $lastUpdate = $this->getLastUpdateTime($name);
        
        // 获取新的漏洞数据
        $vulnerabilities = $source->fetchVulnerabilities($lastUpdate);
        
        if (empty($vulnerabilities)) {
            return [
                'success' => true,
                'new_vulnerabilities' => 0,
                'duration' => microtime(true) - $startTime
            ];
        }

        // 规范化漏洞数据
        $normalizedVulnerabilities = array_map(
            [$this->normalizer, 'normalize'],
            $vulnerabilities
        );

        // 批量插入数据库
        $inserted = $this->batchInsertVulnerabilities($name, $normalizedVulnerabilities);
        
        // 更新最后更新时间
        $this->updateLastUpdateTime($name, time());

        return [
            'success' => true,
            'new_vulnerabilities' => $inserted,
            'total_fetched' => count($vulnerabilities),
            'duration' => microtime(true) - $startTime
        ];
    }

    /**
     * 批量插入漏洞数据
     */
    private function batchInsertVulnerabilities(string $source, array $vulnerabilities): int
    {
        $inserted = 0;
        $batchSize = 1000;
        $batches = array_chunk($vulnerabilities, $batchSize);

        $this->database->beginTransaction();
        
        try {
            foreach ($batches as $batch) {
                $sql = "INSERT IGNORE INTO vulnerabilities 
                        (source, cve_id, package_name, affected_versions, severity, 
                         title, description, published_date, modified_date, 
                         cvss_score, cvss_vector, cwe_ids, references, raw_data) 
                        VALUES ";
                
                $values = [];
                $params = [];
                
                foreach ($batch as $vuln) {
                    $values[] = "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
                    $params = array_merge($params, [
                        $source,
                        $vuln['cve_id'],
                        $vuln['package_name'],
                        json_encode($vuln['affected_versions']),
                        $vuln['severity'],
                        $vuln['title'],
                        $vuln['description'],
                        $vuln['published_date'],
                        $vuln['modified_date'],
                        $vuln['cvss_score'],
                        $vuln['cvss_vector'],
                        json_encode($vuln['cwe_ids']),
                        json_encode($vuln['references']),
                        json_encode($vuln['raw_data'])
                    ]);
                }
                
                $sql .= implode(', ', $values);
                $stmt = $this->database->prepare($sql);
                $stmt->execute($params);
                $inserted += $stmt->rowCount();
            }
            
            $this->database->commit();
        } catch (\Exception $e) {
            $this->database->rollback();
            throw $e;
        }

        return $inserted;
    }

    /**
     * 查询包的漏洞信息
     */
    public function findVulnerabilities(string $packageName, string $version = null): array
    {
        $cacheKey = "vuln:{$packageName}:" . ($version ?: 'all');
        
        // 尝试从缓存获取
        $cached = $this->cache->get($cacheKey);
        if ($cached !== null) {
            return $cached;
        }

        // 从数据库查询
        $sql = "SELECT * FROM vulnerabilities WHERE package_name = ?";
        $params = [$packageName];
        
        if ($version) {
            // 检查版本是否在受影响的版本范围内
            $sql .= " AND JSON_SEARCH(affected_versions, 'one', ?) IS NOT NULL";
            $params[] = $version;
        }
        
        $sql .= " ORDER BY cvss_score DESC, published_date DESC";
        
        $stmt = $this->database->prepare($sql);
        $stmt->execute($params);
        $vulnerabilities = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        // 处理和丰富漏洞数据
        $processedVulnerabilities = $this->processVulnerabilities($vulnerabilities, $version);
        
        // 缓存结果
        $this->cache->set($cacheKey, $processedVulnerabilities, 3600); // 1小时缓存
        
        return $processedVulnerabilities;
    }

    /**
     * 处理漏洞数据
     */
    private function processVulnerabilities(array $vulnerabilities, string $version = null): array
    {
        return array_map(function ($vuln) use ($version) {
            $processed = [
                'id' => $vuln['id'],
                'source' => $vuln['source'],
                'cve_id' => $vuln['cve_id'],
                'package_name' => $vuln['package_name'],
                'severity' => $vuln['severity'],
                'severity_score' => $this->severityMapping[$vuln['severity']] ?? 0,
                'title' => $vuln['title'],
                'description' => $vuln['description'],
                'cvss_score' => (float)$vuln['cvss_score'],
                'cvss_vector' => $vuln['cvss_vector'],
                'cwe_ids' => json_decode($vuln['cwe_ids'], true) ?: [],
                'references' => json_decode($vuln['references'], true) ?: [],
                'published_date' => $vuln['published_date'],
                'modified_date' => $vuln['modified_date'],
                'affected_versions' => json_decode($vuln['affected_versions'], true) ?: []
            ];

            // 如果提供了特定版本，检查是否受影响
            if ($version) {
                $processed['is_affected'] = $this->isVersionAffected(
                    $version, 
                    $processed['affected_versions']
                );
            }

            // 添加修复建议
            $processed['fix_recommendations'] = $this->generateFixRecommendations($processed);
            
            return $processed;
        }, $vulnerabilities);
    }

    /**
     * 检查版本是否受漏洞影响
     */
    private function isVersionAffected(string $version, array $affectedVersions): bool
    {
        foreach ($affectedVersions as $versionRange) {
            if ($this->versionInRange($version, $versionRange)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 检查版本是否在范围内
     */
    private function versionInRange(string $version, array $range): bool
    {
        $minVersion = $range['min'] ?? null;
        $maxVersion = $range['max'] ?? null;
        $minInclusive = $range['min_inclusive'] ?? true;
        $maxInclusive = $range['max_inclusive'] ?? true;

        if ($minVersion) {
            $minCompare = version_compare($version, $minVersion);
            if ($minInclusive) {
                if ($minCompare < 0) return false;
            } else {
                if ($minCompare <= 0) return false;
            }
        }

        if ($maxVersion) {
            $maxCompare = version_compare($version, $maxVersion);
            if ($maxInclusive) {
                if ($maxCompare > 0) return false;
            } else {
                if ($maxCompare >= 0) return false;
            }
        }

        return true;
    }

    /**
     * 生成修复建议
     */
    private function generateFixRecommendations(array $vulnerability): array
    {
        $recommendations = [];

        // 基于CVSS分数的紧急程度
        if ($vulnerability['cvss_score'] >= 9.0) {
            $recommendations[] = [
                'type' => 'urgent',
                'action' => 'immediate_update',
                'description' => '立即更新到安全版本，这是一个严重漏洞'
            ];
        } elseif ($vulnerability['cvss_score'] >= 7.0) {
            $recommendations[] = [
                'type' => 'high_priority',
                'action' => 'scheduled_update',
                'description' => '在下次维护窗口期更新'
            ];
        } else {
            $recommendations[] = [
                'type' => 'low_priority',
                'action' => 'planned_update',
                'description' => '计划在下个版本中更新'
            ];
        }

        // 基于CWE类型的具体建议
        foreach ($vulnerability['cwe_ids'] as $cweId) {
            $cweRecommendation = $this->getCWERecommendation($cweId);
            if ($cweRecommendation) {
                $recommendations[] = $cweRecommendation;
            }
        }

        return $recommendations;
    }

    /**
     * 根据CWE ID获取建议
     */
    private function getCWERecommendation(string $cweId): ?array
    {
        $cweRecommendations = [
            'CWE-79' => [
                'type' => 'xss_protection',
                'action' => 'input_validation',
                'description' => '实施输入验证和输出编码防止XSS攻击'
            ],
            'CWE-89' => [
                'type' => 'sql_injection',
                'action' => 'parameterized_queries',
                'description' => '使用参数化查询防止SQL注入'
            ],
            'CWE-22' => [
                'type' => 'path_traversal',
                'action' => 'path_validation',
                'description' => '验证和限制文件路径访问'
            ],
            'CWE-502' => [
                'type' => 'deserialization',
                'action' => 'safe_deserialization',
                'description' => '避免反序列化不可信数据'
            ]
        ];

        return $cweRecommendations[$cweId] ?? null;
    }

    /**
     * 获取最后更新时间
     */
    private function getLastUpdateTime(string $source): ?int
    {
        $sql = "SELECT last_update FROM vulnerability_sources WHERE source_name = ?";
        $stmt = $this->database->prepare($sql);
        $stmt->execute([$source]);
        $result = $stmt->fetchColumn();
        
        return $result ? (int)$result : null;
    }

    /**
     * 更新最后更新时间
     */
    private function updateLastUpdateTime(string $source, int $timestamp): void
    {
        $sql = "INSERT INTO vulnerability_sources (source_name, last_update) 
                VALUES (?, ?) 
                ON DUPLICATE KEY UPDATE last_update = ?";
        $stmt = $this->database->prepare($sql);
        $stmt->execute([$source, $timestamp, $timestamp]);
    }

    /**
     * 获取漏洞统计信息
     */
    public function getVulnerabilityStats(): array
    {
        $sql = "SELECT 
                    source,
                    severity,
                    COUNT(*) as count,
                    AVG(cvss_score) as avg_cvss_score
                FROM vulnerabilities 
                WHERE published_date > DATE_SUB(NOW(), INTERVAL 30 DAY)
                GROUP BY source, severity
                ORDER BY source, severity";
        
        $stmt = $this->database->prepare($sql);
        $stmt->execute();
        
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * 搜索漏洞
     */
    public function searchVulnerabilities(array $criteria): array
    {
        $sql = "SELECT * FROM vulnerabilities WHERE 1=1";
        $params = [];

        if (!empty($criteria['package_name'])) {
            $sql .= " AND package_name LIKE ?";
            $params[] = '%' . $criteria['package_name'] . '%';
        }

        if (!empty($criteria['severity'])) {
            $sql .= " AND severity = ?";
            $params[] = $criteria['severity'];
        }

        if (!empty($criteria['cve_id'])) {
            $sql .= " AND cve_id = ?";
            $params[] = $criteria['cve_id'];
        }

        if (!empty($criteria['min_cvss_score'])) {
            $sql .= " AND cvss_score >= ?";
            $params[] = $criteria['min_cvss_score'];
        }

        if (!empty($criteria['published_after'])) {
            $sql .= " AND published_date >= ?";
            $params[] = $criteria['published_after'];
        }

        $sql .= " ORDER BY cvss_score DESC, published_date DESC LIMIT 100";

        $stmt = $this->database->prepare($sql);
        $stmt->execute($params);
        
        return $this->processVulnerabilities($stmt->fetchAll(\PDO::FETCH_ASSOC));
    }
}