<?php
namespace YC\CodeAnalysis\SecurityScanner\Vulnerability\Connectors;

use YC\CodeAnalysis\SecurityScanner\Contracts\VulnerabilitySourceInterface;
use YC\CodeAnalysis\Core\Database\DatabaseManager;
use Psr\Log\LoggerInterface;

/**
 * CVE数据库连接器
 * 
 * 连接到NIST CVE数据库，获取最新的CVE信息
 */
class CVEDatabaseConnector implements VulnerabilitySourceInterface
{
    private DatabaseManager $database;
    private LoggerInterface $logger;
    
    // CVE API配置
    private const CVE_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0/';
    private const CVE_FEEDS_BASE = 'https://nvd.nist.gov/feeds/json/cve/1.1/';
    private const REQUESTS_PER_SECOND = 5; // API限制
    private const REQUEST_DELAY = 200000; // 微秒

    public function __construct(DatabaseManager $database, LoggerInterface $logger)
    {
        $this->database = $database;
        $this->logger = $logger;
    }

    /**
     * 获取漏洞数据
     */
    public function fetchVulnerabilities(?int $lastUpdate = null): array
    {
        $vulnerabilities = [];
        
        try {
            // 如果是第一次更新，获取历史数据
            if ($lastUpdate === null) {
                $vulnerabilities = array_merge($vulnerabilities, $this->fetchHistoricalData());
            }
            
            // 获取增量更新数据
            $recentVulnerabilities = $this->fetchRecentVulnerabilities($lastUpdate);
            $vulnerabilities = array_merge($vulnerabilities, $recentVulnerabilities);
            
            // 过滤PHP相关的漏洞
            $phpVulnerabilities = $this->filterPHPRelatedVulnerabilities($vulnerabilities);
            
            $this->logger->info('CVE数据获取完成', [
                'total_vulnerabilities' => count($vulnerabilities),
                'php_related' => count($phpVulnerabilities)
            ]);
            
            return $phpVulnerabilities;
            
        } catch (\Exception $e) {
            $this->logger->error('CVE数据获取失败: ' . $e->getMessage());
            throw $e;
        }
    }

    /**
     * 获取历史CVE数据
     */
    private function fetchHistoricalData(): array
    {
        $vulnerabilities = [];
        $currentYear = (int)date('Y');
        $startYear = 2020; // 从2020年开始获取数据
        
        for ($year = $startYear; $year <= $currentYear; $year++) {
            $this->logger->info("正在获取{$year}年CVE数据");
            
            $yearlyData = $this->fetchCVEByYear($year);
            $vulnerabilities = array_merge($vulnerabilities, $yearlyData);
            
            // 避免API限制
            usleep(self::REQUEST_DELAY);
        }
        
        return $vulnerabilities;
    }

    /**
     * 获取最近的漏洞数据
     */
    private function fetchRecentVulnerabilities(?int $lastUpdate): array
    {
        $vulnerabilities = [];
        $startDate = $lastUpdate ? date('Y-m-d\TH:i:s', $lastUpdate) : date('Y-m-d\TH:i:s', strtotime('-7 days'));
        $endDate = date('Y-m-d\TH:i:s');
        
        $resultsPerPage = 2000;
        $startIndex = 0;
        
        do {
            $url = self::CVE_API_BASE . "?lastModStartDate={$startDate}&lastModEndDate={$endDate}&resultsPerPage={$resultsPerPage}&startIndex={$startIndex}";
            
            $response = $this->makeAPIRequest($url);
            if (!$response || !isset($response['vulnerabilities'])) {
                break;
            }
            
            $batchVulnerabilities = $this->parseCVEResponse($response);
            $vulnerabilities = array_merge($vulnerabilities, $batchVulnerabilities);
            
            $startIndex += $resultsPerPage;
            $totalResults = $response['totalResults'] ?? 0;
            
            // API限流
            usleep(self::REQUEST_DELAY);
            
        } while ($startIndex < $totalResults);
        
        return $vulnerabilities;
    }

    /**
     * 按年份获取CVE数据
     */
    private function fetchCVEByYear(int $year): array
    {
        $vulnerabilities = [];
        
        // 使用数据Feed获取年度数据（更高效）
        $feedUrl = self::CVE_FEEDS_BASE . "nvdcve-1.1-{$year}.json.gz";
        
        $compressedData = $this->downloadFile($feedUrl);
        if (!$compressedData) {
            $this->logger->warning("无法下载{$year}年CVE数据");
            return [];
        }
        
        $jsonData = gzdecode($compressedData);
        if (!$jsonData) {
            $this->logger->error("解压{$year}年CVE数据失败");
            return [];
        }
        
        $data = json_decode($jsonData, true);
        if (!$data || !isset($data['CVE_Items'])) {
            $this->logger->error("解析{$year}年CVE数据失败");
            return [];
        }
        
        foreach ($data['CVE_Items'] as $cveItem) {
            $vulnerability = $this->parseCVEItem($cveItem);
            if ($vulnerability) {
                $vulnerabilities[] = $vulnerability;
            }
        }
        
        return $vulnerabilities;
    }

    /**
     * 发起API请求
     */
    private function makeAPIRequest(string $url): ?array
    {
        $context = stream_context_create([
            'http' => [
                'method' => 'GET',
                'header' => [
                    'User-Agent: YC-PHP-Security-Scanner/1.0',
                    'Accept: application/json'
                ],
                'timeout' => 30
            ]
        ]);
        
        $response = file_get_contents($url, false, $context);
        if ($response === false) {
            $this->logger->error("API请求失败: {$url}");
            return null;
        }
        
        $data = json_decode($response, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            $this->logger->error("JSON解析失败: " . json_last_error_msg());
            return null;
        }
        
        return $data;
    }

    /**
     * 下载文件
     */
    private function downloadFile(string $url): ?string
    {
        $context = stream_context_create([
            'http' => [
                'method' => 'GET',
                'header' => 'User-Agent: YC-PHP-Security-Scanner/1.0',
                'timeout' => 300 // 5分钟超时，下载可能较慢
            ]
        ]);
        
        return file_get_contents($url, false, $context) ?: null;
    }

    /**
     * 解析CVE响应数据
     */
    private function parseCVEResponse(array $response): array
    {
        $vulnerabilities = [];
        
        foreach ($response['vulnerabilities'] ?? [] as $vulnData) {
            $vulnerability = $this->parseVulnerability($vulnData);
            if ($vulnerability) {
                $vulnerabilities[] = $vulnerability;
            }
        }
        
        return $vulnerabilities;
    }

    /**
     * 解析CVE项目（Feed格式）
     */
    private function parseCVEItem(array $cveItem): ?array
    {
        $cve = $cveItem['cve'] ?? [];
        $impact = $cveItem['impact'] ?? [];
        $publishedDate = $cveItem['publishedDate'] ?? null;
        $lastModifiedDate = $cveItem['lastModifiedDate'] ?? null;
        
        return $this->extractVulnerabilityInfo($cve, $impact, $publishedDate, $lastModifiedDate, $cveItem);
    }

    /**
     * 解析漏洞数据（API格式）
     */
    private function parseVulnerability(array $vulnData): ?array
    {
        $cve = $vulnData['cve'] ?? [];
        $publishedDate = $vulnData['published'] ?? null;
        $lastModifiedDate = $vulnData['lastModified'] ?? null;
        
        // 获取CVSS评分
        $metrics = $vulnData['metrics'] ?? [];
        
        return $this->extractVulnerabilityInfo($cve, $metrics, $publishedDate, $lastModifiedDate, $vulnData);
    }

    /**
     * 提取漏洞信息
     */
    private function extractVulnerabilityInfo(array $cve, array $metrics, ?string $publishedDate, ?string $lastModifiedDate, array $rawData): ?array
    {
        $cveId = $cve['id'] ?? $cve['CVE_data_meta']['ID'] ?? null;
        if (!$cveId) {
            return null;
        }

        // 获取描述
        $descriptions = $cve['descriptions'] ?? $cve['description']['description_data'] ?? [];
        $description = '';
        foreach ($descriptions as $desc) {
            if (($desc['lang'] ?? $desc['lang'] ?? '') === 'en') {
                $description = $desc['value'] ?? '';
                break;
            }
        }

        // 获取CVSS评分信息
        $cvssInfo = $this->extractCVSSInfo($metrics);

        // 获取CWE信息
        $cweIds = $this->extractCWEIds($cve);

        // 获取参考链接
        $references = $this->extractReferences($cve);

        // 确定受影响的包
        $affectedPackages = $this->extractAffectedPackages($cve, $rawData);

        return [
            'cve_id' => $cveId,
            'title' => $this->generateTitle($cveId, $description),
            'description' => $description,
            'severity' => $cvssInfo['severity'],
            'cvss_score' => $cvssInfo['score'],
            'cvss_vector' => $cvssInfo['vector'],
            'cwe_ids' => $cweIds,
            'references' => $references,
            'published_date' => $this->formatDate($publishedDate),
            'modified_date' => $this->formatDate($lastModifiedDate),
            'affected_packages' => $affectedPackages,
            'raw_data' => $rawData
        ];
    }

    /**
     * 提取CVSS评分信息
     */
    private function extractCVSSInfo(array $metrics): array
    {
        $defaultInfo = [
            'score' => 0.0,
            'severity' => 'info',
            'vector' => null
        ];

        // 尝试获取CVSS v3.1或v3.0
        foreach (['cvssMetricV31', 'cvssMetricV30'] as $version) {
            if (isset($metrics[$version]) && is_array($metrics[$version])) {
                $cvssData = reset($metrics[$version]);
                $cvssV3 = $cvssData['cvssData'] ?? [];
                
                return [
                    'score' => $cvssV3['baseScore'] ?? 0.0,
                    'severity' => strtolower($cvssV3['baseSeverity'] ?? 'info'),
                    'vector' => $cvssV3['vectorString'] ?? null
                ];
            }
        }

        // 尝试获取CVSS v2
        if (isset($metrics['cvssMetricV2']) && is_array($metrics['cvssMetricV2'])) {
            $cvssData = reset($metrics['cvssMetricV2']);
            $cvssV2 = $cvssData['cvssData'] ?? [];
            $score = $cvssV2['baseScore'] ?? 0.0;
            
            return [
                'score' => $score,
                'severity' => $this->cvssV2ToSeverity($score),
                'vector' => $cvssV2['vectorString'] ?? null
            ];
        }

        // 兼容旧格式
        if (isset($metrics['baseMetricV3']['cvssV3'])) {
            $cvssV3 = $metrics['baseMetricV3']['cvssV3'];
            return [
                'score' => $cvssV3['baseScore'] ?? 0.0,
                'severity' => strtolower($cvssV3['baseSeverity'] ?? 'info'),
                'vector' => $cvssV3['vectorString'] ?? null
            ];
        }

        if (isset($metrics['baseMetricV2']['cvssV2'])) {
            $cvssV2 = $metrics['baseMetricV2']['cvssV2'];
            $score = $cvssV2['baseScore'] ?? 0.0;
            return [
                'score' => $score,
                'severity' => $this->cvssV2ToSeverity($score),
                'vector' => $cvssV2['vectorString'] ?? null
            ];
        }

        return $defaultInfo;
    }

    /**
     * 将CVSS v2评分转换为严重程度
     */
    private function cvssV2ToSeverity(float $score): string
    {
        if ($score >= 7.0) return 'high';
        if ($score >= 4.0) return 'medium';
        if ($score > 0.0) return 'low';
        return 'info';
    }

    /**
     * 提取CWE ID
     */
    private function extractCWEIds(array $cve): array
    {
        $cweIds = [];
        
        // 新格式
        $weaknesses = $cve['weaknesses'] ?? [];
        foreach ($weaknesses as $weakness) {
            foreach ($weakness['description'] ?? [] as $desc) {
                if (($desc['lang'] ?? '') === 'en') {
                    $value = $desc['value'] ?? '';
                    if (strpos($value, 'CWE-') === 0) {
                        $cweIds[] = $value;
                    }
                }
            }
        }

        // 旧格式
        if (empty($cweIds) && isset($cve['problemtype']['problemtype_data'])) {
            foreach ($cve['problemtype']['problemtype_data'] as $problemtype) {
                foreach ($problemtype['description'] ?? [] as $desc) {
                    if (($desc['lang'] ?? '') === 'en') {
                        $value = $desc['value'] ?? '';
                        if (strpos($value, 'CWE-') === 0) {
                            $cweIds[] = $value;
                        }
                    }
                }
            }
        }

        return array_unique($cweIds);
    }

    /**
     * 提取参考链接
     */
    private function extractReferences(array $cve): array
    {
        $references = [];
        
        $refs = $cve['references'] ?? $cve['references']['reference_data'] ?? [];
        foreach ($refs as $ref) {
            $url = $ref['url'] ?? '';
            $name = $ref['name'] ?? basename($url);
            
            if ($url) {
                $references[] = [
                    'name' => $name,
                    'url' => $url,
                    'source' => $ref['refsource'] ?? 'MISC',
                    'tags' => $ref['tags'] ?? []
                ];
            }
        }

        return $references;
    }

    /**
     * 提取受影响的包
     */
    private function extractAffectedPackages(array $cve, array $rawData): array
    {
        $packages = [];
        
        // 从配置数据中提取
        $configurations = $cve['configurations'] ?? $rawData['configurations'] ?? [];
        foreach ($configurations['nodes'] ?? [] as $node) {
            $nodePackages = $this->extractPackagesFromNode($node);
            $packages = array_merge($packages, $nodePackages);
        }

        return $packages;
    }

    /**
     * 从节点提取包信息
     */
    private function extractPackagesFromNode(array $node): array
    {
        $packages = [];
        
        foreach ($node['cpe_match'] ?? [] as $cpeMatch) {
            if (!($cpeMatch['vulnerable'] ?? false)) {
                continue;
            }
            
            $cpe = $cpeMatch['cpe23Uri'] ?? '';
            $packageInfo = $this->parseCPE($cpe);
            
            if ($packageInfo && $this->isPHPRelated($packageInfo)) {
                $packages[] = [
                    'name' => $packageInfo['product'],
                    'vendor' => $packageInfo['vendor'],
                    'version_start' => $cpeMatch['versionStartIncluding'] ?? null,
                    'version_end' => $cpeMatch['versionEndExcluding'] ?? null,
                    'version_start_excluding' => $cpeMatch['versionStartExcluding'] ?? null,
                    'version_end_including' => $cpeMatch['versionEndIncluding'] ?? null,
                    'cpe' => $cpe
                ];
            }
        }

        // 递归处理子节点
        foreach ($node['children'] ?? [] as $childNode) {
            $childPackages = $this->extractPackagesFromNode($childNode);
            $packages = array_merge($packages, $childPackages);
        }

        return $packages;
    }

    /**
     * 解析CPE字符串
     */
    private function parseCPE(string $cpe): ?array
    {
        // CPE格式: cpe:2.3:a:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
        $parts = explode(':', $cpe);
        
        if (count($parts) < 5) {
            return null;
        }

        return [
            'part' => $parts[2] ?? '',
            'vendor' => $parts[3] ?? '',
            'product' => $parts[4] ?? '',
            'version' => $parts[5] ?? '*'
        ];
    }

    /**
     * 检查是否与PHP相关
     */
    private function isPHPRelated(array $packageInfo): bool
    {
        $product = strtolower($packageInfo['product']);
        $vendor = strtolower($packageInfo['vendor']);
        
        // PHP本身
        if ($product === 'php') {
            return true;
        }

        // PHP相关的vendor
        $phpVendors = ['php', 'zend', 'composer', 'packagist', 'symfony', 'laravel', 'drupal', 'wordpress', 'magento'];
        if (in_array($vendor, $phpVendors)) {
            return true;
        }

        // PHP扩展和库
        $phpKeywords = ['php', 'composer', 'packagist', 'phar', 'pdo', 'mysqli'];
        foreach ($phpKeywords as $keyword) {
            if (strpos($product, $keyword) !== false) {
                return true;
            }
        }

        return false;
    }

    /**
     * 过滤PHP相关漏洞
     */
    private function filterPHPRelatedVulnerabilities(array $vulnerabilities): array
    {
        return array_filter($vulnerabilities, function ($vulnerability) {
            // 检查描述中是否包含PHP相关关键词
            $description = strtolower($vulnerability['description']);
            $phpKeywords = ['php', 'composer', 'packagist', 'symfony', 'laravel', 'drupal', 'wordpress', 'magento', 'zend'];
            
            foreach ($phpKeywords as $keyword) {
                if (strpos($description, $keyword) !== false) {
                    return true;
                }
            }

            // 检查是否有PHP包
            if (!empty($vulnerability['affected_packages'])) {
                return true;
            }

            return false;
        });
    }

    /**
     * 生成标题
     */
    private function generateTitle(string $cveId, string $description): string
    {
        // 从描述中提取简洁的标题
        $title = trim(substr($description, 0, 100));
        if (strlen($description) > 100) {
            $title .= '...';
        }
        
        return $title ?: $cveId;
    }

    /**
     * 格式化日期
     */
    private function formatDate(?string $dateString): ?string
    {
        if (!$dateString) {
            return null;
        }

        try {
            $date = new \DateTime($dateString);
            return $date->format('Y-m-d H:i:s');
        } catch (\Exception $e) {
            return null;
        }
    }
}